# -*- coding: utf-8 -*-
"""
Created on Mon Feb 15 2018 
by Brochini L. 

Compares process generated by perfec simulation with 
that generated by a direct simulation given different initial conditions
"""

import numpy as np
import pickle 
import PerfectSim
from matplotlib import pyplot as plt
import pylab

def SimpleSimulation(Wmat,nu,xinit,N,nsteps,simsteps,mu):
    '''
    performs a simple simulation given an initial condition.
    The initial condition xinit is actually a configuration with the length used
    in the 'perfect simulation'
    meaning it is a matrix of zeros and ones of size Nxnsteps
  
    '''
    x=xinit
    if (len(x) != N) or (len(x[0])<nsteps):
        print("Initial condition must have N lines and at least nsteps rows")
        return x        
        
    for n in range(simsteps):
        newrow=np.array([[fillvalue] for it in range(N)])
        x=np.append(x,newrow,axis=1)
        for pos in range(N):
            r=np.random.rand()
            sumeffect=0
            for s in range(nsteps):
                for pre in range(N):
                    sumeffect+=Wmat[pos,pre]*PerfectSim.gfunc(s+1,mu)*x[pre,-s-2]#discount two because last row is already inserted
            p1x=nu[pos]+sumeffect
            if r<p1x:
                x[pos,-1]=1
            else:
                x[pos,-1]=0
    
    return x
        
#%%        
if __name__ == "__main__":    

    D=pickle.load(open("W_nu_valid.pkl","rb"))
    Wmat=D["Wmat"]
    nu=D["nu"]
    N=len(Wmat)
    nsteps=D["nsteps"]
    mu=D["mu"]
    OK,wgmat=PerfectSim.CheckprobAndReturnWG_all(Wmat,nu,nsteps,mu)

    initsize=100
    fillvalue=0.5 # DO NOT USE NAN because of if comparisons. Also do not use 0 or one for obvious reasons.
    maxsteps=10
    
    x=np.zeros([N,initsize])
    x.fill(fillvalue)      
  
    nsims=100000
    
    js_inds,lambda_grid,p_Empty0_1=PerfectSim.BuildLambdaGrid(wgmat,nsteps,N,nu)
   
    
    xtot=np.zeros([N,initsize+maxsteps])
    
    for nsim in range(nsims):
        x=np.zeros([N,initsize])
        x.fill(fillvalue)      
        
        for step in range(maxsteps):        
            newrow=np.array([[fillvalue] for it in range(N)])
            x=np.append(x,newrow,axis=1)        
            for ref_neuron in range(N):
                Path_j_s=[]
                PerfectSim.RecursionUntilEmptyZero(x,ref_neuron,0,lambda_grid,p_Empty0_1,js_inds,Path_j_s,fillvalue)
                PerfectSim.AssignValsToPath(x,Path_j_s,ref_neuron,Wmat)
        xtot+=x
    xtotperf=xtot
                
    #%%    
    
    
    condinits=[]
    condinits.append(np.ones([N,nsteps]))
    condinits.append(np.zeros([N,nsteps]))
    
    for i in range(N):
        aux=np.ones([N,nsteps])
        aux[i,:]=np.ones(nsteps)
        condinits.append(aux)
    
    xtotsimple=[]
    for xinit in condinits:
        simsteps=maxsteps
        xtot=np.zeros([N,nsteps+maxsteps])
        for count in range(nsims):
            xsim=SimpleSimulation(Wmat,nu,xinit,N,nsteps,simsteps,mu)
            xtot+=xsim
        xtotsimple.append(xtot)
       
    
    #%%    
    
    colorscont=['bo-','ro-','go-','co-','mo-']
    colorsdash=['bo--','ro--','go--','co--','mo--']
    
    

    f, axarr = plt.subplots(1,N, sharex=True,figsize=(16,6))
    for neuron in range(N):        
        count=1
        axarr[neuron].plot(range(10),xtotperf[neuron,initsize:initsize+10]/nsims,colorscont[neuron],label='Perfect')
        for xtot in xtotsimple:
            if count==1:
                axarr[neuron].plot(range(10),xtot[neuron,nsteps-1:nsteps-1+10]/nsims,colorsdash[neuron],label='Direct')
                count+=1
            else:
                axarr[neuron].plot(range(10),xtot[neuron,nsteps-1:nsteps-1+10]/nsims,colorsdash[neuron])
        axarr[neuron].set_ylim([0,1])
        axarr[neuron].legend()
        axarr[neuron].set_xlabel('step')
        axarr[neuron].set_title("Neuron "+str(neuron+1))
    axarr[0].set_ylabel('Empirical prob of "firing" for each "neuron"')
    #%%
    pylab.savefig("CompareSim.png")
           
        